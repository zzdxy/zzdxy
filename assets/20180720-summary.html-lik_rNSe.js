import{_ as e}from"./wechatpublic-eLo-9ai1.js";import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as l,o as d,c as n,d as r,e as s}from"./app-WwTsJovB.js";const t="/zzdxy/assets/format_png-0aIk2W-A.png",c="/zzdxy/assets/format_png-1695857270321-3-_6OXhhad.png",h={},u=s(`<h1 id="知识点总结" tabindex="-1"><a class="header-anchor" href="#知识点总结" aria-hidden="true">#</a> 知识点总结</h1><div class="hint-container info"><p class="hint-container-title">共勉</p><p>不要哀求，学会争取。若是如此，终有所获。</p></div><h2 id="const-在不同位置时的不同意义" tabindex="-1"><a class="header-anchor" href="#const-在不同位置时的不同意义" aria-hidden="true">#</a> const 在不同位置时的不同意义</h2><ul><li>指针类型前：声明一个指向常量的指针，程序中不能通过指针来改变它所指向的值，但指针本身的值可以改变，即指针可以指向其他数据；</li><li>&quot;*&quot;号和指针名之间，声明一个指针常量(常指针)，指针本身的值不可改变，即不能指向其他数据，但指向的数据的值可以改变；</li><li>两个地方都加，声明指向常量的指针常量，指针本身的值不可改变，指向的数据也不能通过指针改变；</li></ul><h2 id="函数指针" tabindex="-1"><a class="header-anchor" href="#函数指针" aria-hidden="true">#</a> 函数指针</h2><ul><li>使用函数指针之前，必须先赋值，使它指向一个函数入口地址，赋值语法格式为：函数指针名 = 函数名，其中函数名代表的函数必须是一个已经定义过的，和函数指针具有相同返回类型的函数，指针调用函数格式：<code>(*指针变量)(实参列表)</code>；</li></ul><h2 id="访问权限" tabindex="-1"><a class="header-anchor" href="#访问权限" aria-hidden="true">#</a> 访问权限</h2><ul><li>public：可被任意实体访问；</li><li>protected：只允许本类及子类的成员函数访问；</li><li>private：只允许本类的成员函数访问；</li></ul><h2 id="构造函数" tabindex="-1"><a class="header-anchor" href="#构造函数" aria-hidden="true">#</a> 构造函数</h2><ul><li>创建对象时，自动调用构造函数，不能在程序中直接调用，可有任意类型参数，但不能有返回类型；</li><li>构造函数作用：为对象分配空间、为数据成员赋初值、请求其他资源；</li><li>构造函数工作：初始化虚函数表、建立基类对象、建立非静态数据成员对象、安置虚基类对象信息、执行构造函数体中的代码；</li><li>若一个类中没有定义构造函数，编译器会自动生成不带参数的默认构造函数，格式为：</li></ul><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>&lt;类名&gt;::&lt;默认构造函数名&gt;()
{
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="析构函数" tabindex="-1"><a class="header-anchor" href="#析构函数" aria-hidden="true">#</a> 析构函数</h2><ul><li>析构函数作用：清除对象、释放内存；</li><li>析构函数工作：执行析构函数中的代码、将对象占据的存储空间归还系统、做公共及用户要求的善后工作；</li><li>析构函数无参数和返回值，一个类中只能定义一个析构函数，故不能重载，格式为：</li></ul><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>~&lt;类名&gt;();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="内存布局" tabindex="-1"><a class="header-anchor" href="#内存布局" aria-hidden="true">#</a> 内存布局</h2><ul><li>全局数据区：存放全局变量、静态数据、常量；</li><li>代码区：存放类成员函数、其他函数代码；</li><li>栈区：存放局部变量、函数参数、返回数据、返回地址；</li><li>堆区：自由存储区；</li></ul><h2 id="运算符重载重载形式" tabindex="-1"><a class="header-anchor" href="#运算符重载重载形式" aria-hidden="true">#</a> 运算符重载重载形式</h2><ul><li>重载为类的成员函数，参数个数比原来的运算数少一个</li></ul><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>&lt;函数类型&gt; operator &lt;运算符&gt; (&lt;形参列表&gt;)
{
&lt;函数体&gt;;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>重载为类的友元函数，参数个数与原运算数个数一样多；</li></ul><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>friend &lt;函数类型&gt; operator &lt;运算符&gt; (&lt;形参列表&gt;)

{

&lt;函数体&gt;;

}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>函数重载：返回值类型可以相同可以不同，但形参列表一定不同；</li></ul><h2 id="静态数据成员" tabindex="-1"><a class="header-anchor" href="#静态数据成员" aria-hidden="true">#</a> 静态数据成员</h2><ul><li>初始化格式：<code>&lt;类型&gt;&lt;类名&gt;::&lt;静态数据成员&gt;=&lt;值&gt;;</code></li><li>引用格式：<code>&lt;类名&gt;::&lt;静态数据成员&gt;;</code></li></ul><h2 id="继承方式" tabindex="-1"><a class="header-anchor" href="#继承方式" aria-hidden="true">#</a> 继承方式</h2><ul><li>私有继承 private：父类的公有成员和保护成员作为子类的的私有成员，且不能被子类的派生类访问；</li><li>公有继承 public：父类的公有成员和保护成员作为子类的成员时，仍保持原有状态，父类私有成员仍为私有；</li><li>保护继承 protected：父类的公有成员和保护成员成为子类的保护成员，且只能被他的派生类成员函数或友元访问，父类私有成员仍为私有；</li></ul><figure><img src="`+t+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="派生类构造函数调用顺序" tabindex="-1"><a class="header-anchor" href="#派生类构造函数调用顺序" aria-hidden="true">#</a> 派生类构造函数调用顺序：</h2><ul><li>调用基类的构造函数，调用顺序按继承时说明的顺序；</li><li>调用子对象类的构造函数，调用顺序按在类中说明的顺序；</li><li>派生类构造函数体中内容；</li></ul><h2 id="函数模版" tabindex="-1"><a class="header-anchor" href="#函数模版" aria-hidden="true">#</a> 函数模版</h2><div class="language-C++ line-numbers-mode" data-ext="C++"><pre class="language-C++"><code>template &lt; 模板形参表 &gt;template &lt;typename T&gt;
返回值类型 函数名（形式参数列表）
{
函数体语句
}
例：
template &lt;typename T&gt;
void swap( T&amp; v1, T&amp; v2)
{
T temp;
temp = v1;
v1 = v2;
v2 = temp;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="虚函数" tabindex="-1"><a class="header-anchor" href="#虚函数" aria-hidden="true">#</a> 虚函数</h2><ul><li>虚函数必须是类的成员函数，不能是友元，但可以是另一个类的友元，不能为全局函数，也不能为静态函数，析构函数可以为虚函数，但构造函数不能为虚函数；</li></ul><h2 id="变量初始化" tabindex="-1"><a class="header-anchor" href="#变量初始化" aria-hidden="true">#</a> 变量初始化</h2><ul><li>局部变量：定义时，系统不会进行初始化；</li><li>全局变量：定义时，系统自动初始化，</li></ul><figure><img src="`+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="友元函数" tabindex="-1"><a class="header-anchor" href="#友元函数" aria-hidden="true">#</a> 友元函数</h2><ul><li>在类中定义过，但不是成员函数，定义在类外部，但有权访问类中成员；</li></ul><h2 id="this-指针" tabindex="-1"><a class="header-anchor" href="#this-指针" aria-hidden="true">#</a> this 指针</h2><ul><li>只有成员函数才有 <code>this </code>指针，友元函数没有 <code>this</code> 指针；</li></ul><h2 id="静态成员函数与普通成员函数区别" tabindex="-1"><a class="header-anchor" href="#静态成员函数与普通成员函数区别" aria-hidden="true">#</a> 静态成员函数与普通成员函数区别：</h2><ul><li>静态成员函数没有 <code>this</code> 指针，只能访问静态成员（包括静态成员变量和静态成员函数）；</li><li>普通成员函数有 <code>this</code> 指针，可以访问类中任意成员，而静态成员函数无 <code>this </code>指针；</li></ul><h2 id="⏳-联系" tabindex="-1"><a class="header-anchor" href="#⏳-联系" aria-hidden="true">#</a> ⏳ 联系</h2><p>想解锁更多知识？不妨关注我的微信公众号：<strong>村雨遥（id：JavaPark）</strong>。</p><p>扫一扫，探索另一个全新的世界。</p><figure><img src="'+e+'" alt="" width="150" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',46);function o(v,m){const i=l("Share");return d(),n("div",null,[u,r(i,{colorful:""})])}const f=a(h,[["render",o],["__file","20180720-summary.html.vue"]]);export{f as default};
