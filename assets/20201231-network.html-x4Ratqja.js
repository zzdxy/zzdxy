import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as d,c as s,e,a as t,b as o}from"./app-Svquv1Du.js";const r="/zzdxy/assets/a468e849bf48b218f0a3266e1d9cd5b9-1km_vn1R.webp",l="/zzdxy/assets/6b09a3bc1b49c1cb772d6eedce2f66a9-sriXZl81.webp",n="/zzdxy/assets/b5a6afaaab6917b98040b871ca963f00-kq7OIvu9.webp",i="/zzdxy/assets/6ed01a44de3bc699551d355ec5cb400e-j4FEXUEA.webp",c="/zzdxy/assets/e83d235b519cb62cfe22fec281fbe7d5-Fo_9yKl5.webp",h="/zzdxy/assets/1d5ac6b297456fd31f8e4b9c518f0e53-qQKsme5Z.webp",g="/zzdxy/assets/b606acad67d96dfe7b05087d9f9c5da6-PD_BaR5s.webp",p={},m=e('<h1 id="计算机网络面试知识点" tabindex="-1"><a class="header-anchor" href="#计算机网络面试知识点" aria-hidden="true">#</a> 计算机网络面试知识点</h1><h2 id="_1-计算机网络基础" tabindex="-1"><a class="header-anchor" href="#_1-计算机网络基础" aria-hidden="true">#</a> 1. 计算机网络基础</h2><h3 id="_1-1-主机间的通信方式" tabindex="-1"><a class="header-anchor" href="#_1-1-主机间的通信方式" aria-hidden="true">#</a> 1.1 主机间的通信方式</h3><ol><li><strong>客户端-服务器（C/S）</strong></li></ol><p>客户端是服务的请求放，服务器是服务的提供方。</p><ol start="2"><li><strong>对等（P2P）</strong></li></ol><p>不用区分谁是客户端，谁是服务器，双方都能够向对方请求与提供服务。</p><h3 id="_1-2-电路-分组交换" tabindex="-1"><a class="header-anchor" href="#_1-2-电路-分组交换" aria-hidden="true">#</a> 1.2 电路 &amp; 分组交换</h3><ol><li><strong>分组交换</strong></li></ol><p>每个分组由首部和尾部组成，包含源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互不影响，因此在同一条传输线路上允许同时传输多个分组，即分组交换不会占用传输线路。</p><ol start="2"><li><strong>电路交换</strong></li></ol><p>电路交换用于电话通讯系统，两个用户之间建立通信前需要有一条专用的物理链路，而且在通信过程中始终占用该链路。由于通信过程中不可能一直在使用传输线路，因此电路交换对线路利用率很低，通常不到 10%.</p><h3 id="_1-3-时延" tabindex="-1"><a class="header-anchor" href="#_1-3-时延" aria-hidden="true">#</a> 1.3 时延</h3><ol><li><strong>排队时延</strong></li></ol><p>分组在路由器的输入和输出队列中排队等待所需时间，取决于当前网络的通信量；</p><ol start="2"><li><strong>处理时延</strong></li></ol><p>主机或路由器接收到分组时进行处理所需时间，一般这些处理包括分析首部、从分组中提取数据、进行差错校验或查找适当路由等；</p><ol start="3"><li><strong>传输时延</strong></li></ol><p>主机或路由器传输数据帧所需时间：</p>',19),T=t("p",{class:"katex-block"},[t("span",{class:"katex-display"},[t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[t("semantics",null,[t("mrow",null,[t("mi",null,"d"),t("mi",null,"e"),t("mi",null,"l"),t("mi",null,"a"),t("mi",null,"y"),t("mo",null,"="),t("mi",null,"l"),t("mi",null,"e"),t("mi",null,"n"),t("mi",null,"g"),t("mi",null,"t"),t("mi",null,"h"),t("mo",{stretchy:"false"},"("),t("mi",null,"b"),t("mi",null,"i"),t("mi",null,"t"),t("mo",{stretchy:"false"},")"),t("mi",{mathvariant:"normal"},"/"),t("mi",null,"v"),t("mo",{stretchy:"false"},"("),t("mi",null,"b"),t("mi",null,"i"),t("mi",null,"t"),t("mi",{mathvariant:"normal"},"/"),t("mi",null,"s"),t("mo",{stretchy:"false"},")")]),t("annotation",{encoding:"application/x-tex"}," delay = length(bit)/v(bit/s) ")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),t("span",{class:"mord mathnormal"},"d"),t("span",{class:"mord mathnormal"},"e"),t("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),t("span",{class:"mord mathnormal"},"a"),t("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),t("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),t("span",{class:"mrel"},"="),t("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),t("span",{class:"base"},[t("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),t("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),t("span",{class:"mord mathnormal"},"e"),t("span",{class:"mord mathnormal"},"n"),t("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),t("span",{class:"mord mathnormal"},"t"),t("span",{class:"mord mathnormal"},"h"),t("span",{class:"mopen"},"("),t("span",{class:"mord mathnormal"},"bi"),t("span",{class:"mord mathnormal"},"t"),t("span",{class:"mclose"},")"),t("span",{class:"mord"},"/"),t("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),t("span",{class:"mopen"},"("),t("span",{class:"mord mathnormal"},"bi"),t("span",{class:"mord mathnormal"},"t"),t("span",{class:"mord"},"/"),t("span",{class:"mord mathnormal"},"s"),t("span",{class:"mclose"},")")])])])])],-1),P=t("p",null,[o("其中 "),t("code",null,"length"),o(" 表示数据帧的长度，"),t("code",null,"v"),o(" 表示传输速率；")],-1),u=t("ol",{start:"4"},[t("li",null,[t("strong",null,"传播时延")])],-1),S=t("p",null,"电磁波在信道中传输所需时间，电磁波传播速度无限接近于光速：",-1),_=t("p",{class:"katex-block"},[t("span",{class:"katex-display"},[t("span",{class:"katex"},[t("span",{class:"katex-mathml"},[t("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[t("semantics",null,[t("mrow",null,[t("mi",null,"d"),t("mi",null,"e"),t("mi",null,"l"),t("mi",null,"a"),t("mi",null,"y"),t("mo",null,"="),t("mi",null,"l"),t("mi",null,"e"),t("mi",null,"n"),t("mi",null,"g"),t("mi",null,"t"),t("mi",null,"h"),t("mo",{stretchy:"false"},"("),t("mi",null,"m"),t("mo",{stretchy:"false"},")"),t("mi",{mathvariant:"normal"},"/"),t("mi",null,"v"),t("mo",{stretchy:"false"},"("),t("mi",null,"m"),t("mi",{mathvariant:"normal"},"/"),t("mi",null,"s"),t("mo",{stretchy:"false"},")")]),t("annotation",{encoding:"application/x-tex"}," delay = length(m)/v(m/s) ")])])]),t("span",{class:"katex-html","aria-hidden":"true"},[t("span",{class:"base"},[t("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),t("span",{class:"mord mathnormal"},"d"),t("span",{class:"mord mathnormal"},"e"),t("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),t("span",{class:"mord mathnormal"},"a"),t("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),t("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),t("span",{class:"mrel"},"="),t("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),t("span",{class:"base"},[t("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),t("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),t("span",{class:"mord mathnormal"},"e"),t("span",{class:"mord mathnormal"},"n"),t("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),t("span",{class:"mord mathnormal"},"t"),t("span",{class:"mord mathnormal"},"h"),t("span",{class:"mopen"},"("),t("span",{class:"mord mathnormal"},"m"),t("span",{class:"mclose"},")"),t("span",{class:"mord"},"/"),t("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),t("span",{class:"mopen"},"("),t("span",{class:"mord mathnormal"},"m"),t("span",{class:"mord"},"/"),t("span",{class:"mord mathnormal"},"s"),t("span",{class:"mclose"},")")])])])])],-1),b=e('<p>其中 <code>length</code> 表示信道的长度，<code>v</code> 表示电磁波在信道中的传播速度；</p><h3 id="_1-4-体系结构" tabindex="-1"><a class="header-anchor" href="#_1-4-体系结构" aria-hidden="true">#</a> 1.4 体系结构</h3><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><table><thead><tr><th>体系结构</th><th>协议</th></tr></thead><tbody><tr><td>物理层</td><td>RJ45、CLOCK、IEEE802.3（中继器、集线器）</td></tr><tr><td>数据链路</td><td>PPP、FR、HDLC、VLAN、MAC（网桥、交换机）</td></tr><tr><td>网络层</td><td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）</td></tr><tr><td>传输层</td><td>TCP（HTTP/S、FTP、POP3、SMTP、TENET、SSH）、UDP（BOOTP、NTP、DHCP）、SPX</td></tr><tr><td>会话层</td><td>NFS、SQL、NETBIOS、RPC</td></tr><tr><td>表示层</td><td>JPEG、MPEG、ASII</td></tr><tr><td>应用层</td><td>FTP、DNS、Telenet、SMTP、HTTP、WWW、NFS</td></tr></tbody></table><ol><li><strong>OSI 七层体系结构</strong></li></ol><p>为把在一个网络结构下开发的系统与在另一个网络结构下开发的系统互联起来，以实现更高一级的应用，使异种机之间的通信成为可能，便于网络结构标准化，国际标准化组织（ISO）于1984年形成了开放系统互连参考模型OSI/RM（Open Systems Interconnection Reference Model，简称OSI）的正式文件。</p><ul><li><p><strong>物理层（Physical，PH）：</strong> 传递信息需要利用一些物理传输媒体，如双绞线、同轴电缆、光纤等。物理层的任务就是为上层提供一个物理的连接，以及该物理连接表现出来的机械、电气、功能和过程特性，实现透明的比特流传输。在这一层，数据还没有组织，仅作为原始的比特流提交给上层——数据链路层。</p></li><li><p><strong>数据链路层（Data-link，D）</strong>：数据链路层负责在2个相邻的结点之间的链路上实现无差错的数据帧传输。每一帧包括一定的数据和必要的控制信息，在接收方接收到数据出错时要通知发送方重发，直到这一帧无差错地到达接收结点，数据链路层就是把一条有可能出错的实际链路变成让网络层看起来像不会出错的数据链路。实现的主要功能有：帧的同步、差错控制、流量控制、寻址、帧内定界、透明比特组合传输等。</p></li><li><p><strong>网络层（Network，N）</strong>：网络中通信的2个计算机之间可能要经过许多结点和链路，还可能经过几个通信子网。网络层数据传输的单位是分组（Packet）。网络层的主要任务是为要传输的分组选择一条合适的路径，使发送分组能够正确无误地按照给定的目的地址找到目的主机，交付给目的主机的传输层。</p></li><li><p><strong>传输层（Transport，T）</strong>：传输层的主要任务是通过通信子网的特性，最佳地利用网络资源，并以可靠与经济的方式为2个端系统的会话层之间建立一条连接通道，以透明地传输报文。传输层向上一层提供一个可靠的端到端的服务，使会话层不知道传输层以下的数据通信的细节。传输层只存在端系统中，传输层以上各层就不再考虑信息传输的问题了。</p></li><li><p><strong>会话层（Session，S）</strong>：在会话层以及以上各层中，数据的传输都以报文为单位，会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立以及维护应用之间的通信机制。如服务器验证用户登录便是由会话层完成的。</p></li><li><p><strong>表示层（Presentation，P）</strong>：这一层主要解决用户信息的语法表示问题。它将要交换的数据从适合某一用户的抽象语法，转换为适合OSI内部表示使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩、加密和解密等工作都由表示层负责。</p></li><li><p><strong>应用层（Application，A）</strong>：这是OSI参考模型的最高层。应用层确定进程之间通信的性质以满足用户的需求，以及提供网络与用户软件之间的接口服务。</p></li></ul><ol start="2"><li><strong>五层协议</strong></li></ol><p>我们日常网络中使用的体系结构，总共可以分为 5 层，分别是：</p><ul><li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li><li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><ol start="3"><li><strong>TCP/IP</strong></li></ol><p>不严格遵循 OSI 分层概念，只有四层，相当于将五层协议中的数据链路层和物理层合并为网络结构层。</p><h2 id="_2-五层协议详解" tabindex="-1"><a class="header-anchor" href="#_2-五层协议详解" aria-hidden="true">#</a> 2. 五层协议详解</h2><h3 id="_2-1-物理层" tabindex="-1"><a class="header-anchor" href="#_2-1-物理层" aria-hidden="true">#</a> 2.1 物理层</h3><p>物理层上传送的数据单位是比特，其作用是实现相邻计算机节点间比特流的透明传送，尽可能屏蔽调具体传输介质和屋里设备的差异。根据信息在传输线上的传输方向，可以分为如下三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h3 id="_2-2-链路层" tabindex="-1"><a class="header-anchor" href="#_2-2-链路层" aria-hidden="true">#</a> 2.2 链路层</h3><p>两台主机之间的数据传输，总是在一段一段的链路上进行传送的，此时就需要使用专门的链路层协议。在两个相邻节点间传输数据时，数据链路层将网络层交下来的 IP 数据包组装成帧，在两个相邻节点间的链路上传送帧，每帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><h3 id="_2-3-网络层" tabindex="-1"><a class="header-anchor" href="#_2-3-网络层" aria-hidden="true">#</a> 2.3 网络层</h3><p>互联网的核心，向上提供数据报服务，通过 IP 协议将异构的物理网络连接起来。其任务是选择合适的网间路由和交换节点，从而确保计算机通信的数据及时传送，配套使用的有如下三个协议：</p><ul><li><strong>地址解析协议 ARP</strong></li><li><strong>网际控制报文协议 ICMP</strong></li><li><strong>网际组管理协议 IGMP</strong></li></ul><h3 id="_2-4-传输层" tabindex="-1"><a class="header-anchor" href="#_2-4-传输层" aria-hidden="true">#</a> 2.4 传输层</h3><p>传输层提供了进程间的逻辑通信，负责向两台主机进程之间的通信提供通用的 <strong>数据传输服务</strong>，向高层用户屏蔽网络层的核心细节，这一层中主要涉及 UDP 和 TCP 两个协议。</p><h3 id="_2-5-应用层" tabindex="-1"><a class="header-anchor" href="#_2-5-应用层" aria-hidden="true">#</a> 2.5 应用层</h3><p>应用层的任务是通过应用进程之间的交互来完成特定网络应用，应用层协议定义的是应用进程间的通信和交互的规则。</p><p>对于不同的网络应用需要不同的应用层协议，常见的有 DNS、HTTP、SMTP 协议等；</p><h2 id="_3-http" tabindex="-1"><a class="header-anchor" href="#_3-http" aria-hidden="true">#</a> 3. HTTP</h2><h3 id="_3-1-http-基础" tabindex="-1"><a class="header-anchor" href="#_3-1-http-基础" aria-hidden="true">#</a> 3.1 HTTP 基础</h3><ol><li><strong>URI（统一资源标识符）</strong></li></ol><blockquote><p>URI = URL + URN</p></blockquote><p>URL：统一资源 <strong>定位</strong> 符，标示一个具体的资源位置</p><p>URN：统一资源名称</p><ol start="2"><li><strong>请求报文</strong></li></ol><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>主要由以下三部分构成：</p><ul><li><strong>请求行</strong>：包括请求方法、URL、协议/版本</li><li><strong>请求头</strong>：<code>Request Header</code></li><li><strong>请求正文</strong></li></ul><ol start="3"><li><strong>响应报文</strong></li></ol><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>主要由以下三部分构成：</p><ul><li><strong>状态行</strong></li><li><strong>响应头</strong></li><li><strong>响应正文</strong></li></ul><h3 id="_3-2-http-方法" tabindex="-1"><a class="header-anchor" href="#_3-2-http-方法" aria-hidden="true">#</a> 3.2 HTTP 方法</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>GET</code></td><td>请求指定页面信息，并返回实体主体</td></tr><tr><td><code>POST</code></td><td>传输实体主体，向指定资源提交数据进行处理请求，数据被包含在请求体中，可能会导致新资源的建立和/或已有资源的修改</td></tr><tr><td><code>PUT</code></td><td>从客户端向服务器传送的数据取代指定文档的内容，上传文件 ，不带验证机制，存在安全性问题</td></tr><tr><td><code>DELETE</code></td><td>请求服务器删除指定页面，一般是删除文件</td></tr><tr><td><code>HEAD</code></td><td>获取报文首部，类似于 <code>GET</code>，但不返回报文实体主体部分，主要用于确认 URL 的有效性以及资源更新时间等</td></tr><tr><td><code>PATCH</code></td><td>对资源进行部分修改</td></tr><tr><td><code>OPTIONS</code></td><td>查询支持的方法，查询指定的 URL 能支持的方法，返回 <code>Allow: GET,POST,HEAD,OPTIONS</code> 等内容</td></tr><tr><td><code>CONNECT</code></td><td>要求在于代理服务器通信时建立隧道，使用 SSL 和 TLS 协议将通信内容加密后经网络隧道传输</td></tr><tr><td><code>TRACE</code></td><td>追踪路径，服务器将通信路径返回给客户端</td></tr></tbody></table><h3 id="_3-3-http-状态码" tabindex="-1"><a class="header-anchor" href="#_3-3-http-状态码" aria-hidden="true">#</a> 3.3 HTTP 状态码</h3><p>服务器返回的响应报文中的第一行是状态行，包含状态码以及原因短语，用于告知客户端请求的结果，主要分为如下类型，常见的状态码如下：</p><ul><li><strong>1xx - 信息型</strong>：服务器收到请求，需要请求者继续操作；</li><li><strong>2xx - 成功型</strong>：请求成功收到，理解并处理；</li><li><strong>3xx - 重定向</strong>：需要进一步操作以完成请求；</li><li><strong>4xx - 客户端错误</strong>：请求包含语法错误或无法完成请求；</li><li><strong>5xx - 服务器错误</strong>：服务器在处理请求的过程中发生了错误；</li></ul><table><thead><tr><th>状态码</th><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>100</td><td><code>Continue</code></td><td>到目前为止很正常，客户端能继续发送请求或忽略该响应</td></tr><tr><td>200</td><td><code>OK</code></td><td>表示请求成功</td></tr><tr><td>204</td><td><code>No Content</code></td><td>请求已经成功处理，但返回的响应报文不含实体的主体部分，一般只需要从客户端向服务器发送信息，而无需返回数据时使用</td></tr><tr><td>206</td><td><code>Partial Content</code></td><td>表示客户端进行范围请求，响应报文包含由 <code>Content-Range</code> 指定范围的实体内容</td></tr><tr><td>301</td><td><code>Moved Permanently</code></td><td>永久性重定向</td></tr><tr><td>302</td><td><code>Found</code></td><td>临时性重定向</td></tr><tr><td>303</td><td><code>See Other</code></td><td>和 302 功能相同，但 303 明确要求客户端应该采用 <code>GET</code> 方法获取资源</td></tr><tr><td>304</td><td><code>Not Modified</code></td><td>若请求报文首部包含一些条件，如 <code>If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since</code>，若不满足条件，则服务器返回 304</td></tr><tr><td>307</td><td><code>Temporary Redirect</code></td><td>临时重定向，类似于 302，但 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法</td></tr><tr><td>400</td><td><code>Bad Request</code></td><td>请求报文中存在语法错误</td></tr><tr><td>401</td><td><code>Unauthorized</code></td><td>该状态码表示发送的请求需要有认证信息</td></tr><tr><td>403</td><td><code>Forbidden</code></td><td>请求被拒绝</td></tr><tr><td>404</td><td><code>Not Found</code></td><td>请求的页面不存在</td></tr><tr><td>500</td><td><code>Internal Server Error</code></td><td>服务器正在执行请求时发生错误</td></tr><tr><td>503</td><td><code>Service Unavailable</code></td><td>服务器暂时处于超负载或正进行停机维护，现在无法处理请求</td></tr></tbody></table><h3 id="_3-4-http-首部" tabindex="-1"><a class="header-anchor" href="#_3-4-http-首部" aria-hidden="true">#</a> 3.4 HTTP 首部</h3><p>有 4 中类型的首部字段：</p><ul><li><strong>通用首部字段</strong></li><li><strong>请求首部字段</strong></li><li><strong>响应首部字段</strong></li><li><strong>实体首部字段</strong></li></ul><h3 id="_3-5-get-vs-post" tabindex="-1"><a class="header-anchor" href="#_3-5-get-vs-post" aria-hidden="true">#</a> 3.5 GET vs POST</h3><ol><li><strong>作用不同</strong></li></ol><p><code>GET</code> 用于获取资源，一般是查询，而 <code>POST</code> 用于传输实体主体，一般是提交；</p><ol start="2"><li><strong>参数不同</strong></li></ol><p><code>GET</code> 和 <code>POST</code> 的请求都能使用额外参数，但 <code>GET</code> 的参数以查询字符串出现在 URL 中，不会对服务器中的内容产生作用，但 <code>POST</code> 的参数存储在实体主体中。但是 <code>POST</code> 的安全性也不能说很高，我们仍然可以用抓包工具来进行查看。另一方面，URL 只支持 ASCII，因此 GET 的参数中若有中文等字符时需要先进行编码，但是 POST 的参数支持标准字符集；</p><ol start="3"><li><strong>安全性</strong></li></ol><p>GET 方法是安全的，因为它不会改变服务器的状态。但是 POST 非安全，因为 POST 的目的是传送实体主体内容，内容可能是用户上传的表单数据，一旦上传成功，服务器就可能把该数据存入数据库，此时状态也就发生了改变。</p><p>安全的方法：<code>GET、HEAD、OPTIONS</code>；</p><p>不安全的方法：<code>POST、PUT、DELETE</code>；</p><ol start="4"><li><strong>幂等性</strong></li></ol><p>幂等的 HTTP 方法，同样的请求被执行一次和被连续执行多次的效果是一样的，服务器的状态也一样，即幂等的方法不具有副作用，因此所有安全的方法也都是幂等的。</p><p>一般来说，<code>GET、HEAD、PUT、DELETE</code> 等方法都是幂等的，但 <code>POST</code> 不是。</p><ol start="5"><li><strong>可缓存</strong></li></ol><p>若要对响应进行缓存，则应该满足一下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 <code>GET、HEAD</code>，但是 <code>PUT、DELETE</code> 不可缓存，<code>POST</code> 在大多数情况下是不可缓存的；</li><li>响应报文的状态码是可缓存的，包括：200、203、204、206、300、301、404、405、410、411、501；</li><li>响应报文的 <code>Cache-Control</code> 首部字段未指定则不进行缓存；</li></ul><h2 id="_4-http-和-https" tabindex="-1"><a class="header-anchor" href="#_4-http-和-https" aria-hidden="true">#</a> 4. HTTP 和 HTTPS</h2><h3 id="_4-1-什么是-http-s-协议" tabindex="-1"><a class="header-anchor" href="#_4-1-什么是-http-s-协议" aria-hidden="true">#</a> 4.1 什么是 HTTP/S 协议？</h3><ol><li><strong>HTTP</strong></li></ol><p>HTTP（Hyper Text Transfer Protocol），<strong>超文本传输协议</strong>，它是从 Web 服务器传输超文本标记语言（HTML）到本地浏览器的传送协议。</p><p>HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法；</p><ol start="2"><li><strong>HTTPS</strong></li></ol><p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer），以安全为目标的 HTTP 通道，通俗来讲就是 HTTP 的安全版，加入了 SSL/TLS 层，通过 SSL 证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。HTTPS 的安全基础是 SSL，其主要作用有如下两种：</p><ul><li>建立一个信息安全通道，来保证数据传输的安全；</li><li>确认网站真实性；</li></ul><h3 id="_4-2-http-s-特点" tabindex="-1"><a class="header-anchor" href="#_4-2-http-s-特点" aria-hidden="true">#</a> 4.2 HTTP/S 特点</h3><ol><li><strong>HTTP</strong></li></ol><ul><li>HTTP 支持 C/S 模式，是一种 <strong>请求/响应模式</strong> 的协议；</li><li><strong>简单快速</strong>：客户向服务器请求服务时，只需要传送请求方法和路径，常用方法有 <code>GET、POST、HEAD</code>；</li><li><strong>灵活</strong>：HTTP 允许传输任意类型的数据对象，传输数据的类型由 <code>Content - Type</code> 来标记；</li><li><strong>无连接</strong>：限制每次连接只处理一个请求，服务器处理完请求并受到客户的应答后，会断开连接，但是不利于客户端和服务器保持会话连接；</li><li><strong>无状态</strong>：值协议对于事务处理没有回忆，后续处理如果需要前面的信息，则必须重传；</li></ul><h3 id="_4-2-http-s-原理" tabindex="-1"><a class="header-anchor" href="#_4-2-http-s-原理" aria-hidden="true">#</a> 4.2 HTTP/S 原理</h3><ol><li><strong>HTTP</strong></li></ol><p>HTTP 是 <strong>基于 TCP/IP 通信协议来传递数据的协议</strong>，传输的数据类型有 HTML 文件、图片文件、查询结果等。此外，HTTP 协议一般用于 <code>B/S</code> 架构，浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务器即 Web 服务器发送所有请求；</p><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li><strong>HTTPS</strong></li></ol><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如上图，使用 HTTPS 传输数据的流程如下：</p><ol><li>首先客户端通过 URL 访问服务器建立 SSL 连接；</li><li>服务器收到客户端请求后，将网站支持的证书信息（其中包含公钥）传送一份给客户端；</li><li>客户端的服务器开始协商 SSL 连接的安全等级，即信息加密的等级；</li><li>客户端的浏览器根据双方同意的安全等级，建立会话秘钥，然后利用网站的公钥将会话秘钥加密，并传送给网站；</li><li>服务器利用自己的秘钥解密出会话秘钥；</li><li>服务器利用会话秘钥加密与客户端之间的通信；</li></ol><h3 id="_4-3-http-和-https-的区别" tabindex="-1"><a class="header-anchor" href="#_4-3-http-和-https-的区别" aria-hidden="true">#</a> 4.3 HTTP 和 HTTPS 的区别</h3><p>HTTP 协议传输的数据都是未经加密的，即明文的，因此使用 HTTP 协议传输隐私信息不安全。为了保证隐私数据能够加密传输，于是使用 SSL 协议用于对 HTTP 协议传输的数据进行加密，即 HTTPS；</p><p>HTTPS 协议是 HTTP + SSL 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 更加安全，两者的区别主要有：</p><ol><li>HTTPS 需要到 CA 申请证书，一般免费证书较少，因此需要一定费用；</li><li>HTTP 是超文本传输信息，信息是明文传输；HTTPS 是具有安全性的 SSL 加密传输协议；</li><li>HTTP 和 HTTPS 使用的是完全不同的连接方式，HTTP 默认使用 <code>80</code> 端口，而 HTTPS 默认使用 <code>443</code> 端口；</li><li>HTTP 的连接简单，是无状态的；而 HTTPS 是 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全；</li></ol><table><thead><tr><th>区别</th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>协议</td><td>基于 TCP，明文传输，<strong>客户端与服务器端均无法验证对方身份</strong></td><td>HTTP + SSL，运行于 TCP 之上，<strong>添加了加密和认证机制的 HTTP</strong></td></tr><tr><td>端口</td><td>80</td><td>443</td></tr><tr><td>资源消耗</td><td>较少</td><td>由于加解密操作，将消耗更多的 CPU 和内存资源</td></tr><tr><td>开销</td><td>无需证书</td><td>需要证书，一般是向认证机构购买</td></tr><tr><td>加密机制</td><td>无</td><td>共享秘钥加密和公开秘钥加密并用的混合加密机制</td></tr><tr><td>安全性</td><td>弱</td><td>强</td></tr></tbody></table><h2 id="_5-tcp-vs-udp" tabindex="-1"><a class="header-anchor" href="#_5-tcp-vs-udp" aria-hidden="true">#</a> 5. TCP VS UDP</h2><h3 id="_5-1-tcp-和-udp-的特点" tabindex="-1"><a class="header-anchor" href="#_5-1-tcp-和-udp-的特点" aria-hidden="true">#</a> 5.1 TCP 和 UDP 的特点</h3><ol><li><strong>TCP</strong></li></ol><p>TCP（传输控制协议，Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供 <strong>全双工通信，面向字节流</strong> （将应用层传下来的报文当做字节流，将字节流组织为大小不等的数据块），每条 TCP 连接只能是 <strong>点对点（一对一）</strong>，总结起来有如下特点：</p><ul><li><strong>面向连接</strong></li><li><strong>仅支持单播</strong></li><li><strong>面向字节流</strong></li><li><strong>可靠性</strong></li><li><strong>提供拥塞控制以及全双工通信</strong></li></ul><ol start="2"><li><strong>UDP</strong></li></ol><p>UDP（用户数据表协议，User Datagram Protocol）是面向无连接的，尽最大可能交付，无拥塞控制，<strong>面向报文</strong>（对应用层中传下来的报文不合并也不拆分，只添加 UDP 首部），支持 <strong>一对一、一对多、多对一和对多点的交互通信</strong>，总结起来有如下特点：</p><ul><li><strong>面向无连接</strong></li><li><strong>有单播、多播、广播的功能</strong></li><li><strong>面向报文</strong></li><li><strong>不可靠性</strong></li><li><strong>头部开销小，传输数据时高效</strong></li></ul><h3 id="_5-2-tcp-vs-udp" tabindex="-1"><a class="header-anchor" href="#_5-2-tcp-vs-udp" aria-hidden="true">#</a> 5.2 TCP VS UDP</h3><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接</td><td>无连接</td></tr><tr><td>是否可靠</td><td>可靠传输，使用流量控制和拥塞控制</td><td>不可靠传输，不使用流量控制和拥塞控制</td></tr><tr><td>连接对象个数</td><td>只能一对一</td><td>支持一对一、一对多、多对一和多对多</td></tr><tr><td>传输方式</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>首部开销</td><td>首部最小 20 字节，最大 60 字节</td><td>首部开销小，仅 8 字节</td></tr><tr><td>场景</td><td>传输可靠，比如文件传输等</td><td>实时应用，比如视频会议、直播等</td></tr></tbody></table><h3 id="_5-3-三次握手以及四次挥手" tabindex="-1"><a class="header-anchor" href="#_5-3-三次握手以及四次挥手" aria-hidden="true">#</a> 5.3 三次握手以及四次挥手</h3><ol><li><strong>三次握手</strong></li></ol><ul><li><strong>第一次握手</strong>：客户端向服务端发送连接请求报文段，报文段中含有自身的数据通讯初始序号。请求发送后，客户端进入 <code>SYN-SENT</code> 状态；</li><li><strong>第二次握手</strong>：服务端接收到来自客户端的连接请求报文，如果同意就会发送一个响应，响应中也会包含自身的数据通讯初始序号，发送完成后进入 <code>SYN-RECEIVED</code> 状态；</li><li><strong>第三次握手</strong>：客户端收到来自服务端同意连接的响应后，再次向服务端发送一个确认报文。客户端发送完该报文后进行 <code>ESTABLISHED</code> 状态，服务端收到该应答后也进入 <code>ESTABLISHED</code> 状态，此时连接就建立成功了。</li></ul><figure><img src="'+h+'" alt="源自 ThinkWon 博客" tabindex="0" loading="lazy"><figcaption>源自 ThinkWon 博客</figcaption></figure><ol start="2"><li><strong>四次挥手</strong></li></ol><ul><li><strong>第一次挥手：</strong> 一旦客户端 A 认为数据发送完成，则向服务端 B 发送请求释放请求；</li><li><strong>第二次挥手：</strong> 服务端 B 收到连接释放请求后，将告知应用层释放 TCP 连接，接着发送 ACK 包并进入 <code>CLOST_WAIT</code> 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据。但是 TCP 是双向通信的，所以 B 此时仍可以向 A 发送数据；</li><li><strong>第三次挥手：</strong> 若 B 此时还有未发送完的数据，就会继续发送直到完毕，然后向 A 发送连接释放请求，接着 B 进入 <code>LAST-ACK</code> 状态；</li><li><strong>第四次挥手：</strong> A 收到释放请求后，向 B 发送确认应答，此时 A 进入 <code>TIME-WAIT</code> 状态并持续一段时间（一般是 2MSL），若在该时间段内没有来自 B 的重发请求，就进入 <code>CLOSED</code> 状态。当 B 收到确认应答后，也进入 <code>CLOSE</code> 状态。</li></ul><figure><img src="'+g+'" alt="图源自 Thinkwon 博客" tabindex="0" loading="lazy"><figcaption>图源自 Thinkwon 博客</figcaption></figure><h2 id="_6-session-vs-cookie" tabindex="-1"><a class="header-anchor" href="#_6-session-vs-cookie" aria-hidden="true">#</a> 6. Session vs Cookie</h2><h3 id="_6-1-session-和-cookie-的定义" tabindex="-1"><a class="header-anchor" href="#_6-1-session-和-cookie-的定义" aria-hidden="true">#</a> 6.1 Session 和 Cookie 的定义</h3><h4 id="_6-1-1-什么是-cookie" tabindex="-1"><a class="header-anchor" href="#_6-1-1-什么是-cookie" aria-hidden="true">#</a> 6.1.1 什么是 cookie</h4><p><code>cookie</code> 是由 Web 服务器保存在用户浏览器上的小文件（<code>key-value</code> 格式），包含用户相关信息。客户端向服务器发起请求，若服务器需要记录该用户状态，则使用 <code>response</code> 向客户端浏览器颁发一个 <code>cookie</code>。客户端浏览器将 <code>cookie</code> 保存起来，当浏览器再请求该网站时，浏览器将请求的网址连同该 <code>cookie</code> 一起提交给服务器，服务器检查该 <code>cookie</code>，以此来确认用户身份。</p><h4 id="_6-1-2-什么是-session" tabindex="-1"><a class="header-anchor" href="#_6-1-2-什么是-session" aria-hidden="true">#</a> 6.1.2 什么是 session</h4><p><code>session</code> 依赖于 <code>cookie</code> 实现，<code>session</code> 是服务端对象。<code>session</code> 浏览器和服务器会话过程中，服务器分配的一块存储空间。服务器默认为浏览器在 <code>cookie</code> 中设置 <code>sessionid</code>，浏览器在向服务器请求过程中传输 <code>cookie</code> 包含 <code>sessionid</code>，服务器将根据 <code>sessionid</code> 获取出会话中存储的信息，然后确认会话的身份信息。</p><h3 id="_6-2-session-和-cookie-的区别" tabindex="-1"><a class="header-anchor" href="#_6-2-session-和-cookie-的区别" aria-hidden="true">#</a> 6.2 Session 和 Cookie 的区别</h3><ol><li><strong>存储空间</strong>：单个 <code>cookie</code> 所保存的数据不能超过 4k，许多浏览器都会限制一个站点最多能保存的 <code>cookie</code> 数（一般是 20），但是 <code>session</code> 没有该限制；</li><li><strong>占用服务器资源</strong>：<code>session</code> 一定时间保存在服务器上，当访问增多时，占用服务器性能，考虑到服务器性能方面，应当使用 <code>cookie</code>；</li><li><strong>存储位置与安全性</strong>：<code>cookie</code> 数据放在客户端，安全性较差，<code>session</code> 数据放在服务器上，安全性相对较高；</li></ol><h2 id="_7-常见面试题" tabindex="-1"><a class="header-anchor" href="#_7-常见面试题" aria-hidden="true">#</a> 7. 常见面试题</h2><h3 id="_7-1-tcp-连接为什么不是-2-次-而是-3-次" tabindex="-1"><a class="header-anchor" href="#_7-1-tcp-连接为什么不是-2-次-而是-3-次" aria-hidden="true">#</a> 7.1 TCP 连接为什么不是 2 次，而是 3 次？</h3><p>因为考虑到连接时丢包的问题，如果是 2 次，那么第二次握手时如果服务器响应给客户端的确认报文段丢失，但此时服务器端已经准备好接收数据，而客户端一直没收到服务端的确认报文，客户端就不清楚服务端是否已经准备好了。这样一来，客户端既不会向服务端发送数据，也会忽略服务端所发送过来的数据。</p><h3 id="_7-2-发出-4-次挥手的确认报文后为什么要等-2msl-的时间才能释放-tcp-连接" tabindex="-1"><a class="header-anchor" href="#_7-2-发出-4-次挥手的确认报文后为什么要等-2msl-的时间才能释放-tcp-连接" aria-hidden="true">#</a> 7.2 发出 4 次挥手的确认报文后为什么要等 2MSL 的时间才能释放 TCP 连接？</h3><p>同样是出于考虑丢包问题，若第四次挥手的报文丢失，服务器未确认 Ack 报文就会重发第三次挥手的报文，若报文一来一去的最常时间就是 2 MSL，所以需要等这么长时间来确认服务端确实已经收到。</p>',118),f=[m,T,P,u,S,_,b];function x(H,y){return d(),s("div",null,f)}const C=a(p,[["render",x],["__file","20201231-network.html.vue"]]);export{C as default};
