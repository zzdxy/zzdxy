import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as e,e as n}from"./app-TNlY5Ty6.js";const t="/zzdxy/assets/1-qZzgjb7r.png",o={},c=n('<h1 id="mybatis-面试知识点" tabindex="-1"><a class="header-anchor" href="#mybatis-面试知识点" aria-hidden="true">#</a> MyBatis 面试知识点</h1><h2 id="hibernate-简介" tabindex="-1"><a class="header-anchor" href="#hibernate-简介" aria-hidden="true">#</a> Hibernate 简介</h2><h3 id="什么是-hibernate" tabindex="-1"><a class="header-anchor" href="#什么是-hibernate" aria-hidden="true">#</a> 什么是 Hibernate？</h3><p><code>Hibernate</code> 是一种 <code>ORM（Object Relational Mapping）</code> 框架，用于在 <code>Java</code> 对象和关系数据库之间建立某种映射，从而实现 <code>Java</code> 对象存取；</p><h3 id="hibernate-优缺点" tabindex="-1"><a class="header-anchor" href="#hibernate-优缺点" aria-hidden="true">#</a> Hibernate 优缺点</h3><h4 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h4><p><code>Hibernate</code> 建立在 <code>POJO</code> 和数据库表模型的直接映射关系之上。通过 <code>XML</code> 或者注解就能和数据库表进行映射。通过 <code>POJO</code> 直接就能操作数据库中的数据，提供的是对于全表的映射模型。主要有如下优点：</p><ol><li>消除了代码映射规则，被分离到 <code>XML</code> 或注解中配置；</li><li>配置在 <code>XML</code> 中后，无需再管理数据库连接；</li><li>一个会话中，不用操作多个对象，只要操作 <code>Session</code> 对象即可；</li><li>关闭资源只需关闭 <code>Session</code>；</li></ol><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h4><ol><li>由于是全表映射，所以某些操作不方便，比如更新需要发送所有字段；</li><li>无法根据不同条件组装不同的 <code>SQL</code>；</li><li>对多表关联和复杂 <code>SQL</code> 查询支持较差，需要自己写 <code>SQL</code>，返回后还需要自己将数据组成 <code>POJO</code>；</li><li>不能有效支持存储过程；</li></ol><h2 id="mybatis-简介" tabindex="-1"><a class="header-anchor" href="#mybatis-简介" aria-hidden="true">#</a> MyBatis 简介</h2><h3 id="什么是-mybatis" tabindex="-1"><a class="header-anchor" href="#什么是-mybatis" aria-hidden="true">#</a> 什么是 MyBatis？</h3><p>MyBatis 一款支持自定义 SQL 查询、存储过程和高级映射的持久层框架，消除了几乎所有 JDBC 代码和参数的手动配置以及结果集的检索。只需要使用 XML 或注解进行配置和映射，MyBatis 就能将参数映射到配置的 SQL 形成最终执行的 SQL 语句，最后将执行 SQL 的结果映射为 Java 对象返回；</p><h3 id="mybatis-优缺点" tabindex="-1"><a class="header-anchor" href="#mybatis-优缺点" aria-hidden="true">#</a> MyBatis 优缺点</h3><h4 id="优点-1" tabindex="-1"><a class="header-anchor" href="#优点-1" aria-hidden="true">#</a> 优点</h4><ol><li>小巧，学习成本低，会写 SQL 语句就能很快上手；</li><li>无需过多配置 JDBC，主要专注 SQL 开发；</li><li>方便维护管理，SQL 不用在 Java 代码中找，SQL 代码可以分离重用；</li><li>灵活，支持动态 SQL；</li><li>支持对象与数据库 ORM 字段关系映射；</li></ol><h4 id="缺点-1" tabindex="-1"><a class="header-anchor" href="#缺点-1" aria-hidden="true">#</a> 缺点</h4><ol><li>主要工作集中在 SQL 开发，所以对 SQL 熟练度要求较高；</li><li>移植性查，SQL 依赖于数据库，切换不同数据库会因语法差异而报错；</li></ol><h3 id="mybatis-和-hibernate-的区别" tabindex="-1"><a class="header-anchor" href="#mybatis-和-hibernate-的区别" aria-hidden="true">#</a> MyBatis 和 Hibernate 的区别</h3><h4 id="相同点" tabindex="-1"><a class="header-anchor" href="#相同点" aria-hidden="true">#</a> 相同点</h4><p>均是对 JDBC 的封装，都是持久层的框架，用于 Dao 层的开发；</p><h4 id="不同点" tabindex="-1"><a class="header-anchor" href="#不同点" aria-hidden="true">#</a> 不同点</h4><table><thead><tr><th></th><th>映射关系</th><th>SQL优化和移植性</th><th>开发难易程度和学习成本</th></tr></thead><tbody><tr><td>Hibernate</td><td>全自动映射，配置 Java 对象与数据库表的对应关系，多表关联关系配置复杂</td><td>对 SQL 语句封装，提供了日志、缓冲、级联等特性，此外还提供 HQL 操作数据库，数据库无关系支持好，但会多消耗性能</td><td>重量级，门槛高，适合需求稳定、中小型项目</td></tr><tr><td>MyBatis</td><td>半自动映射，配置 Java 对象与 SQL 语句执行结果的对应关系，多表关联关系配置简单</td><td>需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程；开发工作量相对较大，直接使用 SQL 语句操作数据库，不支持数据库无关性，但 SQL 语句优化容易</td><td>轻量级，门槛低，适合需求变化频繁、大型项目</td></tr></tbody></table><p>Hibernate 属于全自动的 ORM 映射工具，使用 Hibernate 查询关联对象或关联集合对象时，能根据对象关系模型直接获取，所以说它是全自动的；</p><p>而 MyBatis 属于半自动 ORM 映射工具，因为在查询关联对象或关联集合对象时，需要自己手动编写 SQL 来完成；</p><h2 id="解析和运行原理" tabindex="-1"><a class="header-anchor" href="#解析和运行原理" aria-hidden="true">#</a> 解析和运行原理</h2><h3 id="mybatis-核心组件" tabindex="-1"><a class="header-anchor" href="#mybatis-核心组件" aria-hidden="true">#</a> MyBatis 核心组件</h3><ol><li><strong>构造器</strong>：<code>SqlSessionFactoryBuilder</code>，根据配置信息或点来生成 <code>SqlSessionFactory</code>；</li><li><strong>工厂接口</strong>：<code>SqlSessionFactory</code>，依靠工厂来生成 <code>SqlSession</code>；</li><li><strong>会话</strong>：<code>SqlSession</code>，是一个既可以发送 SQL 去执行返回结果，也可以获取 <code>Mapper</code> 接口；</li><li><strong>SQL Mapper</strong>：新设计的组件，由一个 Java 接口和 XML 文件（或注解）构成，需要给出对象的 SQL 和映射规则。负责发送 SQL 去执行，并返回结果；</li></ol><h3 id="mybatis-编程步骤" tabindex="-1"><a class="header-anchor" href="#mybatis-编程步骤" aria-hidden="true">#</a> MyBatis 编程步骤</h3><ol><li>创建 <code>SqlSessionFactory</code>；</li><li>通过 <code>SqlSessionFactory</code> 创建 <code>SqlSession</code>；</li><li>通过 <code>SqlSession</code> 执行数据库操作；</li><li>调用 <code>session.commit()</code> 提交事务；</li><li>调用 <code>session.close()</code> 关闭会话；</li></ol><h3 id="mybatis-工作原理" tabindex="-1"><a class="header-anchor" href="#mybatis-工作原理" aria-hidden="true">#</a> MyBatis 工作原理</h3><figure><img src="'+t+`" alt="MyBatis工作原理，源自网络" tabindex="0" loading="lazy"><figcaption>MyBatis工作原理，源自网络</figcaption></figure><ol><li><strong>首先读取 <code>MyBatis</code> 配置文件</strong>：<code>mybatis-config.xml</code>，它是 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息；</li><li><strong>接着加载映射文件</strong>，即 SQL 映射文件，其中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 <code>mybatis-config.xml</code> 中加载。它可以加载多个映射文件，每个文件对应数据表中的一张表；</li><li><strong>构造会话工厂</strong>，通过 <code>mybatis</code> 的环境等配置信息构建会话工厂 <code>SqlSessionFactory</code>；</li><li><strong>创建会话对象</strong>，由会话工厂创建 <code>SqlSession</code> 对象，该对象包含执行 SQL 语句的所有方法；</li><li><strong><code>Executor</code> 执行器</strong>，MyBatis 底层定义了一个 Executor 接口来操作数据库，它根据 <code>SqlSession</code> 传递的参数动态生成所需执行的 SQL 语句，同时负责查询缓存的维护；</li><li><strong><code>MappedStatement</code> 对象</strong>，在 <code>Executor</code> 接口的执行方法中有一个 <code>MappedStatement</code> 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 <code>id</code>，参数等信息；</li><li><strong>输入参数映射</strong>，输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型，此过程类似于 JDBC 对 <code>preparedStatement</code> 对象设置参数的过程；</li><li><strong>输出结果映射</strong>，输出结果类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型，此过程类似于 JDBC 对结果集的解析过程；</li></ol><h2 id="映射器" tabindex="-1"><a class="header-anchor" href="#映射器" aria-hidden="true">#</a> 映射器</h2><h3 id="和-的区别" tabindex="-1"><a class="header-anchor" href="#和-的区别" aria-hidden="true">#</a> \${} 和 #{} 的区别</h3><ol><li><code>\${}</code> 是拼接符，字符串替换，无预编译处理；<code>#{}</code> 是占位符，预编译处理；</li><li>处理 <code>#{}</code> 时，传入参数以 <strong>字符串传入</strong>，会将 SQL 中的 <code>#{}</code> 替换为 <code>?</code> ，调用 <code>PreparedStatement</code> 中的 <code>set</code> 方法来赋值；</li><li>处理 <code>\${}</code> 时，是 <strong>原值传入</strong>，会将 <code>\${}</code> 替换为变量的值，相当于 JDBC 中的 <code>Statement</code> 编译；</li><li>变量替换后 ，<code>#{}</code> 对应变量自动加上单引号 <code>‘’</code>，而 <code>\${}</code> 对应变量不会加单引号 <code>‘’</code>；</li><li><code>#{}</code> 能有效防止 SQL 注入，提高系统安全性，原因在于 <strong>预编译机制</strong>，预编译完成后，SQL 的结构已经固定，即使用户输入非法参数，也不会对 SQL 结构产生影响，从而避免潜在的安全风险；但 <code>\${}</code> 不能防止 SQL 注入；</li><li><code>#{}</code> 的变量替换是在 DBMS 中；<code>\${}</code> 的变量替换是在 DBMS 外；</li></ol><p><strong>预编译定义</strong>：预编译是提前对 SQL 语句进行编译，而后注入的参数不会再进行 SQL 编译；而一般 SQL 注入是发生在编译过程中，因为恶意注入了某些特殊字符，最后被编译为了恶意的执行操作，而预编译机制则能很好的防止 SQL 注入；</p><p><strong>SQL 注入定义</strong>：Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击；主要有 <strong>广泛性、隐蔽性、危害大、操作方便</strong> 等特点；</p><h3 id="模糊查询-like" tabindex="-1"><a class="header-anchor" href="#模糊查询-like" aria-hidden="true">#</a> 模糊查询 like</h3><ol><li><code>&#39;%{question}%&#39;</code> 可能引起 SQL 注入，不推荐使用；</li><li><code>&quot;%{question}%&quot;</code>，因为 <code>#{}</code> 在解析时会在最外侧自动加单引号，所以外层需要使用双引号，不能使用单引号，否则将查询不到任何结果；</li><li><code>CONCAT(&#39;%&#39;, #{question}, &#39;%&#39;)</code>，使用 <code>CONCAT()</code> 函数，推荐使用；</li><li>使用 <code>bind</code> 标签；</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">&quot;user&quot;</span> resultType<span class="token operator">=</span><span class="token string">&quot;com.cunyu.User&quot;</span><span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>bind name<span class="token operator">=</span><span class="token string">&quot;pattern&quot;</span> value <span class="token operator">=</span> <span class="token string">&quot;&#39;%&#39; + userName + &#39;%&#39;&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token class-name">SELECT</span> id<span class="token punctuation">,</span> sex<span class="token punctuation">,</span> age<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password from persion where username <span class="token constant">LIKE</span> #<span class="token punctuation">{</span>pattern<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="mapper-中如何传递多个参数" tabindex="-1"><a class="header-anchor" href="#mapper-中如何传递多个参数" aria-hidden="true">#</a> mapper 中如何传递多个参数</h3><ol><li><strong>顺序传参</strong></li></ol><p><code>#{}</code> 中的数字代表传入参数的顺序，不推荐使用，因为 SQL 层表达不直观，而且一旦顺序跳转则容易出错；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">selectUser</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">&quot;selectUser&quot;</span> resultMap<span class="token operator">=</span><span class="token string">&quot;UserResultMap&quot;</span><span class="token operator">&gt;</span>
    <span class="token constant">SELECT</span> <span class="token operator">*</span> <span class="token constant">FROM</span> user <span class="token class-name">WHERE</span> user_name <span class="token operator">=</span> #<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span> and id <span class="token operator">=</span> #<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>@Param 注解传参</strong></li></ol><p><code>#{}</code> 中的名称对应注解 <code>@Param</code> 括号中修饰的名称，是更加推荐的一种方式；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">selectUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">&quot;id&quot;</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">&quot;selectUser&quot;</span> resultMap<span class="token operator">=</span><span class="token string">&quot;UserResultMap&quot;</span><span class="token operator">&gt;</span>
    <span class="token constant">SELECT</span> <span class="token operator">*</span> <span class="token constant">FROM</span> user <span class="token class-name">WHERE</span> user_name <span class="token operator">=</span> #<span class="token punctuation">{</span>name<span class="token punctuation">}</span> and id <span class="token operator">=</span> #<span class="token punctuation">{</span>id<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><strong>Map 传参</strong></li></ol><p><code>#{}</code> 中的名称对应的是 Map 中的 <code>key</code> 名称，适合传递多个参数，且参数易变且能灵活传递的情况；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">selectUser</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">&quot;selectUser&quot;</span> resultMap<span class="token operator">=</span><span class="token string">&quot;UserResultMap&quot;</span><span class="token operator">&gt;</span>
    <span class="token constant">SELECT</span> <span class="token operator">*</span> <span class="token constant">FROM</span> user <span class="token class-name">WHERE</span> user_name <span class="token operator">=</span> #<span class="token punctuation">{</span>name<span class="token punctuation">}</span> and id <span class="token operator">=</span> #<span class="token punctuation">{</span>id<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li><strong>Java Bean 传参</strong></li></ol><p><code>#{}</code> 中名称对应的是类中的成员属性，通过这种方法更加直观，代码可读性强、业务逻辑处理方便；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">selectUser</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">&quot;selectUser&quot;</span> parameterType<span class="token operator">=</span><span class="token string">&quot;com.cunyu.pojo.User&quot;</span> resultMap<span class="token operator">=</span><span class="token string">&quot;UserResultMap&quot;</span><span class="token operator">&gt;</span>
    <span class="token constant">SELECT</span> <span class="token operator">*</span> <span class="token constant">FROM</span> user <span class="token class-name">WHERE</span> user_name <span class="token operator">=</span> #<span class="token punctuation">{</span>name<span class="token punctuation">}</span> and id <span class="token operator">=</span> #<span class="token punctuation">{</span>id<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="mybatis-批量操作" tabindex="-1"><a class="header-anchor" href="#mybatis-批量操作" aria-hidden="true">#</a> MyBatis 批量操作</h3><h4 id="使用-foreach-标签" tabindex="-1"><a class="header-anchor" href="#使用-foreach-标签" aria-hidden="true">#</a> 使用 foreach 标签</h4><p><code>foreach</code> 主要用于构建 <code>in</code> 条件中，可以在 SQL 语句中进行迭代一个集合。<code>foreach</code> 标签的属性主要有 <code>item、index、collection、open、separator、close</code>；</p><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td><code>item</code></td><td>表示集合中每个元素进行迭代时的别名，随便取的变量名</td></tr><tr><td><code>index</code></td><td>指定一个名字，用于表示在迭代过程中，每次迭代到的位置</td></tr><tr><td><code>collection</code></td><td>必须指定，但在不同情况下的值不一样：<br>1. 若传入单参数且参数类型是 <code>List</code>，则其属性值为 <code>list</code><br>2. 若传入单参数且参数类型是一个数组，则其属性置为 <code>array</code><br>3. 若传入参数是多个时，需要将其封装为一个 <code>Map</code></td></tr><tr><td><code>open</code></td><td>表示该语句以什么开始，常用 <code>(</code></td></tr><tr><td><code>separator</code></td><td>表示在每次进行迭代之间以何种符号作为分隔符，常用 <code>,</code></td></tr><tr><td><code>close</code></td><td>表示该语句以什么结束，常用 <code>)</code></td></tr></tbody></table><h4 id="使用-executortype-batch" tabindex="-1"><a class="header-anchor" href="#使用-executortype-batch" aria-hidden="true">#</a> 使用 ExecutorType.BATCH</h4><p>MyBatis 内置的 <code>ExecutorType</code> 有 3 种，默认为 <code>simple</code>，此时它为每个语句的执行创建了一个新的预处理语句，单挑提交 SQL；而 <code>batch</code> 模式重复使用已预处理的语句，且批量执行所有更新数据，其性能比 <code>batch</code> 更优；</p><h2 id="mybatis-分页及原理" tabindex="-1"><a class="header-anchor" href="#mybatis-分页及原理" aria-hidden="true">#</a> MyBatis 分页及原理</h2><p>MyBatis 内部是通过 <code>RowBounds</code> 对象进行分页，它是针对 <code>ResultSet</code> 结果集执行的内存分页，而非物理分页，可以直接编写带物理分页的参数的 SQL 实现分页，也可以 MyBatis 的分页插件 Page-Helper；</p><p><strong>分页插件的基本原理：</strong> 使用 MyBatis 所提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 <code>dialect</code> 方言，添加对应物理分页语句和物理分页参数；</p>`,63),i=[c];function d(r,p){return s(),e("div",null,i)}const h=a(o,[["render",d],["__file","20210822-mybatis.html.vue"]]);export{h as default};
